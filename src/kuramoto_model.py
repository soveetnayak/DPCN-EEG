# -*- coding: utf-8 -*-
"""code1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SsID52nkQNgtnK6tcFN9YZ2_m8vlcQHg
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from tqdm import tqdm
from scipy.integrate import odeint


class Kuramoto:
    def __init__(self, coupling, dt, T, n_nodes):
        self.dt = dt
        self.T = T
        self.coupling = coupling
        self.n_nodes = n_nodes
        self.natfreqs = np.random.normal(size=self.n_nodes)

    def derivative(self, angles_vec, t, adj_mat, k):
        angles_i, angles_j = np.meshgrid(angles_vec, angles_vec)
        interactions = adj_mat * np.sin(angles_j - angles_i)  # Aij * sin(j-i)
        dxdt = self.natfreqs + k * interactions.sum(
            axis=0
        )  # sum over incoming interactions
        return dxdt

    def integrate(self, angles_vec, adj_mat):
        n_interactions = (adj_mat != 0).sum(axis=0)  # number of incoming interactions
        k = (
            self.coupling / n_interactions
        )  # normalize coupling by number of interactions
        t = np.linspace(0, self.T, int(self.T / self.dt))
        timeseries = odeint(self.derivative, angles_vec, t, args=(adj_mat, k))
        return timeseries.T

    def run(self, adj_mat=None, angles_vec=None):
        angles_vec = 2 * np.pi * np.random.random(size=self.n_nodes)
        return self.integrate(angles_vec, adj_mat)

    @staticmethod
    def phase_coherence(angles_vec):
        suma = sum([(np.e ** (1j * i)) for i in angles_vec])
        return abs(suma / len(angles_vec))


def plot_phase_coupling(file, save=False):
    df = pd.read_csv(file, header=None)
    file = file.split("/")[-1]
    data_num = file.split("_")[-2]
    fragment_num = file.split("_")[-1].split(".")[0]
    print(
        "Generating plot for data_num: ", data_num, " and fragment_num: ", fragment_num
    )

    A = df.values
    print(A)
    adjMatrix = np.array(A)
    n = len(adjMatrix)

    # Run model with different coupling (K) parameters (0.2, 0.4, 0.6, 0.8)
    coupling_vals = np.linspace(0, 0.6, 100)
    runs = []
    for coupling in tqdm(coupling_vals):
        model = Kuramoto(coupling=coupling, dt=0.01, T=1000, n_nodes=n)
        model.natfreqs = np.random.normal(1, 0.1, size=n)  # reset natural frequencies
        act_mat = model.run(adjMatrix)
        runs.append(act_mat)

    runs_array = np.array(runs)

    mean_phase_coherences = []
    std_phase_coherences = []
    for i, coupling in tqdm(enumerate(coupling_vals)):
        r_values = [model.phase_coherence(vec) for vec in runs_array[i, :, -1000:].T]
        r_mean = np.mean(r_values)
        r_std = np.std(r_values)
        mean_phase_coherences.append(r_mean)
        std_phase_coherences.append(r_std)

    # Plot mean phase coherence curve
    plt.figure()
    Kc = np.sqrt(8 / np.pi) * np.std(model.natfreqs)  # analytical result (from paper)
    plt.vlines(Kc, 0, 1, linestyles="--", color="orange", label="analytical prediction")
    plt.plot(
        coupling_vals, mean_phase_coherences, color="blue", label="Mean Phase Coherence"
    )
    plt.xlabel("Coupling (K)")
    plt.ylabel("Phase Coherence")
    plt.title("Phase Coherence vs Coupling Strength")
    plt.legend()
    plt.grid(True)
    if save:
        plt.savefig("../figures/" + data_num + "_" + fragment_num + "_mean.png")
    else:
        plt.show()

def plot_parameter_fragment(data_num, save=False):
    '''
    For a single time series take few values of coupling(0.2,0.4,0.6,0.8) and plot order parameter wrt the 14 segments.So it's order parameter vs epileptogenic zone i.e 14 segments.

    The plot will give info of how the oscillators are synchronized throughout different epileptogenic zone at various couplings.
    '''

    data = [ pd.read_csv(f'../data/binary/{data_num}_{i}.csv', header=None) for i in range(14) ]
    data = [df.values for df in data]
    data = np.array(data)
    n_nodes = data[0].shape[0]
    coupling_vals = np.linspace(0.2, 0.8, 4)
    order_parameters = []
    
    print(f'Generating plot for data_num: {data_num}')

    for coupling in coupling_vals:
        print(f'Running for coupling: {coupling}')
        model = Kuramoto(coupling=coupling, dt=0.01, T=1000, n_nodes=n_nodes)
        model.natfreqs = np.random.normal(1, 0.4, size=n_nodes)  # reset natural frequencies
        order_params = []
        for i in range(14):
            print(f'Running for segment: {i}')
            act_mat = model.run(data[i])
            r_values = [model.phase_coherence(vec) for vec in act_mat[:, -1000:].T]
            r_mean = np.mean(r_values)
            order_params.append(r_mean)
        order_parameters.append(order_params)

    order_parameters = np.array(order_parameters)
    print(order_parameters.shape)
    
    plt.figure()
    for i, coupling in enumerate(coupling_vals):
        plt.plot(order_parameters[i], label=f'Coupling: {coupling}')
    plt.xlabel('Epileptogenic Zone')
    plt.ylabel('Order Parameter')
    plt.title('Order Parameter vs Epileptogenic Zone')
    plt.legend()
    plt.grid(True)

    if save:
        plt.savefig(f'../figures/{data_num}_order_zone.png')
    else:
        plt.show()

# Usage

plot_phase_coupling("../data/binary/111g0L_10.csv")
# plot_parameter_fragment('111g0L')

# for i in range(14):
#     generate_plot("../data/binary/111g0L_" + str(i) + ".csv", save=True)
#     generate_plot("../data/binary/112g0L_" + str(i) + ".csv", save=True)
#     generate_plot("../data/binary/113g0R_" + str(i) + ".csv", save=True)
